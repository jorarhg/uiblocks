{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport { FormatterFunction, FormatterType, FormatterContext, FormatterResult } from '@/types/formatters'\nimport { DefaultFormatter } from './default-formatter'\nimport { BadgeFormatter } from './badge-formatter'\nimport { DateFormatter } from './date-formatter'\nimport { CurrencyFormatter } from './currency-formatter'\nimport { PercentageFormatter } from './percentage-formatter'\nimport { IconFormatter } from './icon-formatter'\nimport { IconTextFormatter } from './icon-text-formatter'\nimport { CustomFormatter } from './custom-formatter'\nimport { HtmlFormatter } from './html-formatter'\nimport { LinkFormatter } from './link-formatter'\nimport { ImageFormatter } from './image-formatter'\n\n// Registry de formatters disponibles\nexport const FORMATTERS: Record<FormatterType, FormatterFunction> = {\n  default: DefaultFormatter,\n  badge: BadgeFormatter,\n  date: DateFormatter,\n  currency: CurrencyFormatter,\n  percentage: PercentageFormatter,\n  icon: IconFormatter,\n  'icon-text': IconTextFormatter,\n  custom: CustomFormatter,\n  html: HtmlFormatter,\n  link: LinkFormatter,\n  image: ImageFormatter,\n}\n\n/**\n * Función principal para aplicar formateo a una celda\n */\nexport function formatCell(context: FormatterContext): FormatterResult {\n  const { field } = context\n  \n  if (!field.formatter) {\n    return DefaultFormatter(context)\n  }\n  \n  const formatter = FORMATTERS[field.formatter.type]\n  if (!formatter) {\n    console.warn(`Formatter type '${field.formatter.type}' not found, using default`)\n    return DefaultFormatter(context)\n  }\n  \n  try {\n    const result = formatter(context)\n    \n    // Aplicar formateo condicional si existe\n    const conditionalResult = applyConditionalFormatting(context, result)\n    \n    return conditionalResult\n  } catch (error) {\n    console.error(`Error in formatter '${field.formatter.type}':`, error)\n    return DefaultFormatter(context)\n  }\n}\n\n/**\n * Aplica formateo condicional basado en condiciones\n */\nfunction applyConditionalFormatting(\n  context: FormatterContext, \n  baseResult: FormatterResult\n): FormatterResult {\n  const { field, value, record } = context\n  const conditionalFormats = field.formatter?.options?.conditionalFormatting || field.conditionalFormatting || []\n  \n  if (!conditionalFormats.length) {\n    return baseResult\n  }\n  \n  // Buscar la primera condición que se cumpla\n  for (const format of conditionalFormats) {\n    let conditionMet = false\n    \n    if (typeof format.condition === 'function') {\n      conditionMet = format.condition(value, record)\n    } else if (typeof format.condition === 'string') {\n      // Evaluar condición como string (ej: \"value > 10\")\n      try {\n        conditionMet = evaluateCondition(format.condition, value, record)\n      } catch (error) {\n        console.warn('Error evaluating condition:', format.condition, error)\n        continue\n      }\n    }\n    \n    if (conditionMet) {\n      // Si hay un formatter específico, usarlo\n      if (format.formatter) {\n        const newContext = { ...context, field: { ...context.field, formatter: format.formatter } }\n        return formatCell(newContext)\n      }\n      \n      // Aplicar solo estilos condicionales\n      return {\n        ...baseResult,\n        className: combineClassNames(baseResult.className, format.className),\n        style: { ...baseResult.style, ...format.style }\n      }\n    }\n  }\n  \n  return baseResult\n}\n\n/**\n * Evalúa una condición de string de manera segura\n */\nfunction evaluateCondition(condition: string, value: any, record: any): boolean {\n  // Reemplazar 'value' y 'record' en la condición\n  const safeCondition = condition\n    .replace(/\\bvalue\\b/g, JSON.stringify(value))\n    .replace(/\\brecord\\.(\\w+)\\b/g, (_, prop) => JSON.stringify(record[prop]))\n  \n  // Solo permitir operadores seguros\n  const allowedOperators = /^[\\d\\s\\+\\-\\*\\/\\(\\)\\>\\<\\=\\!\\&\\|\\.\\\"\\'\\w]+$/\n  if (!allowedOperators.test(safeCondition)) {\n    throw new Error('Unsafe condition')\n  }\n  \n  // Evaluar usando Function constructor (más seguro que eval)\n  return new Function('return ' + safeCondition)()\n}\n\n/**\n * Combina nombres de clases CSS\n */\nfunction combineClassNames(...classes: (string | undefined)[]): string {\n  return classes.filter(Boolean).join(' ')\n}\n\n/**\n * Aplica template a un valor (ej: \"TASK-{value}\" con value=\"123\" -> \"TASK-123\")\n */\nexport function applyTemplate(template: string, value: any, record?: any): string {\n  if (!template) return String(value || '')\n  \n  return template\n    .replace(/\\{value\\}/g, String(value || ''))\n    .replace(/\\{record\\.(\\w+)\\}/g, (_, prop) => String(record?.[prop] || ''))\n}\n\n/**\n * Utilidad para crear un formatter personalizado\n */\nexport function createCustomFormatter(\n  render: (context: FormatterContext) => React.ReactNode\n): FormatterFunction {\n  return (context) => ({\n    content: render(context)\n  })\n}\n\n// Re-exportar tipos para facilitar el uso\nexport type { FormatterFunction, FormatterContext, FormatterResult, FormatterType } from '@/types/formatters'\n"]}